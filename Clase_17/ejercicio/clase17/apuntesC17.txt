
MEMORIA ESTATICA(Tiempo de programacion/tiempo de edicion)

char nombres [10][51]; // una vez declarado no me puedo pasar de 10 nombres y si quiero 11 nombres debo ingresar al archivo y editar el 10

MEMORIA DINAMICA (Tiempo de Ejecucion)

para no quedarnos cortos y no limitar la cantidad de ingresos, utilizo esto, asi no necesito entrar a editar el archivo, no va a haber un desperdicio de memoria, se va a ajustar

malloc (memory allocation) declaramos un array y no le decimos una cantidad sino que con esta funcion se dimensiona y luego se redimensiona con realloc (reallocation)

Reserva dinámica de memoria(pag4 Memoria_v2.pdf)

struct Persona per, *p;
p=&per; //al puntero p le asigno la ubicacion de memoria per(ya lo dejamos de hacer, porque estoy duplicando la variable)

si trabajo con memoria dinamica puedo prescindir de p=&per;
Entonces:

struct Persona *p; //es una var del tipo persona, cuantos bytes tiene? 63bytes la estructura, pero este puntero tiene 2 bytes; PORQUE cualquier puntero tiene 2 bytes me alcanza para guardar el nro de dire de mem que gurda el puntero como dato

scanf("%d",&p->fechaNac.dia); //PUEDO HACER ESTO? NO porque estoy metiendo un dato de 4bytes(fechaNac.dia es un int) en un puntero de 2bytes 
como hago esto sin necesidad de otra variable? tengo que pedir MEMORIA DINAMICA ANTES DE HACER EL SCANF, entonces: USO MALLOC //devuelve un puntero a VOID, ese puntero es versàtil, voy a ocupar dos bytes en ese puntero que va a guardar una dir de memoria, al ser void puedo usarla con cualquier tipo de dato
QUE RECIBE? un entero sin signo, porque lo que va a recibir es la cantidad de bytes que voy  reservar; si la estructura tiene 63 bytes (por ej char nombre) voy a reservar 63bytes

casteo para tener la dire de comienzo de la estructura, en el int sin signo le digo que cant de bytes que reservar, como se el tipo de dato, uso sizeof(struct Persona) y lo asigno al puntero p
p=(struct Persona*)malloc(sizeof(struct Persona));

struct Persona *p;

p=(struct Persona*)malloc(sizeof(struct Persona));

si no hay memoria disponible no va a retornar un puntero sino NULL (sirve para no hacer lio), entonces voy a preguntar si p!=NULL para poder hacer esto, si es igual a null avisa que no hay mas memoria

struct Persona *p;

p=(struct Persona*)malloc(sizeof(struct Persona));

if(p!=NULL){
	p->fecNac.dia
	p->nombre
}

entonces malloc me permite reservar memoria dinámica

realloc, me permite redimensionar esa memoria dinámica que pedí en caso que me tenga que exceder de la dimensión original

REALLOC // ver pag 6 Memoria_v2.pdf
trabaja igual que malloc, la única diferencia, el prototipo recibe dos parámetros el 1ro es la dire de memoria de comienzo del bloque original (que ya tengo pedido por malloc o realloc anterior); el 2do cant de bytes que voy a pedir(pero tengo que pedir el total, incluido lo que ya tengo)

struct Persona *p;

p=(struct Persona*)malloc(sizeof(struct Persona)*3);//pido mas de una estructura, entonces la asigno para 3

if(p!=NULL){
	p->fecNac.dia
	p->nombre
}

lleno las 3 estructuras y me encuentro que tengo que dar de alta un elemento más, entonces uso realloc

struct Persona *p;

p=(struct Persona*)malloc(sizeof(struct Persona)*3);//pido mas de una estructura, entonces la asigno para 3

if(p!=NULL){
	p->fecNac.dia
	p->nombre
}

p=(struct Persona*)realloc(p, sizeof(struct Persona)*6);//siempre agrega memoria de forma consecutiva a la reservada, en caso que no haya espacio consecutivo, entonces busca la próxima ubicación libre, cambiando la direccion de memoria ya que el bloque se cambio de direccion (tiene que entrar todo en la memoria, en cuanto no entra pasa a la siguiente ubicacion) si no encuentra en ninguna ubicacion la memoria suficiente, retorna NULL, entonces p=NULL, LOS DATOS QUE TENIA GUARDADOS AL COMIENZO ANTES DEL REALLOC SE BORRAN entonces necesito un aux de p para no perder los datos de una

struct Persona *p, *pAux;

p=(struct Persona*)malloc(sizeof(struct Persona)*3);//pido mas de una estructura, entonces la asigno para 3

if(p!=NULL){
	p->fecNac.dia
	p->nombre
}

pAux=(struct Persona*)realloc(p, sizeof(struct Persona)*6);

if(pAux!=NULL){ //controlo que sea una dir de memoria valida 
	p=pAux; //y recien ahi le asigno la dire de pAux a p
}

LIBERACIÓN DINÁMICA DE MEMORIA //necesito saber que no voy a acceder más a esa dirección para liberarla
la funcion que uso es

struct Persona *p, *pAux;

p=(struct Persona*)malloc(sizeof(struct Persona)*3);//pido mas de una estructura, entonces la asigno para 3

if(p!=NULL){
	p->fecNac.dia
	p->nombre
}

pAux=(struct Persona*)realloc(p, sizeof(struct Persona)*6);

if(pAux!=NULL){ 
	p=pAux;
}

free(p);
free(pAux);

devuelve VOID
recibe UN PUNTERO A VOID

el puntero libera la memoria y queda con valor NULL

no puedo hacer free de p y repetirlo, me da error de ejecucion
tampoco puedo hacer free de un puntero que apunta a null

Ejemplo de asignación, redimensionamiento y liberación de memoria (pag 7 copiar codigo y hacerlo funcionar, tiene un error, dejé la linea erronea comentada y la copie en la línea correcta)
