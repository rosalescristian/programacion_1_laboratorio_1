CLASE 18 - ARCHIVOS

2 tipos de archivos

1-BINARIOS cuando queramos visualizarlo vemos código máquina/binario
2-TEXTO texto plano. cuando lo abramos vamos a poder ver todo el contenido, para trabajar con esto debemos desarmar campo a campo las estructuras para poder intervenirlos

los datos escalares y numericos solo los vamos a ver como caracteres binarios

la gran diferencia entre los dos tipos(1 y 2), los binarios se pueden trabajar con estructuras(dentro de la estructura tiene diferentes tipos de datos encapsulados-podemos trabajar un registro, array de estructuras, podemos guardar estos datos en ese archivo, en el disco)

cualquiera de los dos tipos de archivo, se guardan en el disco en código máquina/binario

voy a hacer una app que escriba y lea y muestre como texto plano un archivo binario

0b00100001 (0b indica que es sistema binario, 0x indica sistema hexadecimal)

los nros--->si son int ocupan 4bytes si son texto ocupan 1byte por dígito

si quiero guardar 45678 como binario se ocupan 4bytes y como texto 5bytes(1b/dígito)

depende lo que tenga que hacer, se usan archiuvos tipo texto o tipo binario

el archivo de tipo binario trabaja de manera entrelazada con lo que son las estructuras, mucho más rápido

en un archivo binario se guardan datos con distintos formatos, caract mezclados con int y floats, la interpretacion de los datos guardados cambia

Si tomamos el último ejemplo dado para archivos de texto y queremos escribir en el archivo el número 45678 , en el programa va a estar definido como un entero y por lo tanto se escribirán 2 bytes al archivo. El número quedaría de la siguiente forma: 0b1011001001101110 (16bits)

////////Trabajo sobre archivos

vamos a trabajar con archivos que usan buffer

ARCHIVOS BINARIOS - algunas funciones

fopen //abre el archivo ()

fclose //cierra el archivo

fread //lee el archivo

fwrite //escribe en el archivo

fcloseall//cierra todos los archivos abiertos

feof //End Of File - retorna valor indicando si se llego al final del archivo o no - 
puedo recorrer los registros del archivo guardado en disco, en búsqueda de un dato por ejemplo, para esto necesito alguna manera de saber si enb ese recorrido llegué al final del archivo--->para ello existe la función feof

ferror //indica si hay un error

frewind //los señaladores dentro del disco se pueden correr un lugar, con lo cual usamos esta función que "rebobina" al archivo para hacer la búsqueda desde el comienzo del archivo

fseek //te podes mover tantos registros como necesites, desde la posición actual del señalador

ftell //me dice cant de bytes desde un comienzo a un final de una seleccion del archivo, o todo el archivo- (uno puede ver cuánto ocupa un archivo gracias a esta función)
getc con un solo caracter y a traves de archivos
putc trabaja solo sobre archivos

fputs //cadena de caracteres

fscanf //similar a scanf en vez de levantar de teclado levanta desde archivo

fprintf //imprimo en un archivo del tipo texto printf//imprimo en pantalla

PAGINA 5 - gráfico
escritura- de la memoria al disco
lectura- del disco a la memoria

cada archivo fisico va a estar asociado a la estructura FILE

uso puntero porque voy a necesitar relacionar

ya no vamos a usar nom[] sino *nom (son lo mismo pero ahora solo usaremos *nom)

MODOS - VER PAG 7
r //abre archivo de texto para lectura// rb para binario
w //escritura archivo de texto// wb para binario
a //añadir al final

r+b //lectura y escritura binario
w+b//lectura y escritura binario

a+b

si el archivo no existe y uso r me da ERROR

si uso w y el archivo no existe lo crea, si el archivo existe, lo sobre escribe, es decir borra el original y lo pisa con uno nuevo vacío//para evitar eso se usa primero abrir con r

si hay error en apertura de archivo va a retornar NULL

si hace apertura devuelve dir de memoria donde tengo el enlace al archivo

Veamos un ejemplo:
#include <stdio.h>
void main (void)
{
	FILE *parch;
	if((parch=fopen("banco.dat","rb"))==NULL)
	{
		printf("\nEl archivo no puede ser abierto");
		exit (1); //NO HACER ESTO SINO DARLE LA OPCION AL USER DE VOLVER AL PASO ANTERIOR O HACER OTRA ACCIÓN O ELEGIR ÉL MISMO SI CERRAR EL PROGRAMA
	}
	fclose(parch);
}

En el ejemplo se utiliza un if para detectar la correcta apertura del archivo. Se debe recordar
que cuando la función 'fopen()' retorna NULL significa que se ha fallado en abrir el archivo en
el modo solicitado.

Para crear un archivo por primera vez se debe usar el modo w, pero primero nos debemos
asegurar que el archivo no exista, ya que en ese caso el contenido del archivo se borra. Para
contemplar esta situación se modifica levemente el código del ejemplo.

void main (void)
{
	FILE *parch;
	//Se abre en modo lectura
	if((parch=fopen("banco.dat","rb"))==NULL)
	{
		//Si el modo anterior dio error el archivo
		if((parch=fopen("banco.dat","wb"))==NULL)
		{
			printf("\nEl archivo no puede ser abierto");
			exit (1);
		}
		//no existe, por lo tanto se crea
		fclose(parch);
	}
}

La idea es abrir un archivo para leer, en el caso de que exista se trabaja normalmente, pero si
no existe lo abre el segundo 'fopen()' .
De esta forma nos evitamos borrar un archivo que existe y tiene datos.

En el caso de querer ingresar el nombre del archivo por teclado, el programa se modifica de la
siguiente manera:

void main (void)
{
	FILE *parch;
	char nombre[20];
	printf("\nIngrese el nombre y ruta del archivo que desea abrir: ");
	gets(nombre);
	if((parch=fopen( nombre ,"rb"))==NULL)
	{
		if((parch=fopen( nombre ,"wb"))==NULL)
		{
			printf("\nEl archivo %s no puede ser abierto",nombre);
			exit (1);
		}
		fclose(parch);
	}
}

fcloseall//no existe en linuux con lo cual tendría que usar un fclose por archivo abierto

devuelve un nro entero que es la cant de archivos cerrados, sino da NULL


Escritura de un archivo //una vez abierto el archivo lo puedo escribir

int fwrite ( void * origen , size_t tamaño , size_t cantidad , FILE *arch);

origen: Es un puntero al lugar desde donde se obtienen los datos para escribir en el
archivo si saco los datos de una variable q es una estructura, sera $variable del tipo estructura // es nuestro 1er param


tamaño: Es el tamaño en bytes del dato que se va a escribir suponiendo q es una estruct sizeof del struct
cantidad: Es la cantidad de datos de longitud tamaño que se van a escribir //cantidad de datos dentro de la estructura



Ejemplo: Si queremos escribir en un archivo de texto:
FILE *parch;
char texto[ ]="Prueba de escritura";
int cant , longi;
if((parch=fopen("prueba.txt","w"))==NULL) //Se abre en modo escritura
{
	printf("\nEl archivo no puede ser abierto");
	exit (1);
}

longi=strlen (texto );
cant=fwrite ( texto , sizeof ( char ) , longi , parch );//Se escribe al archivo // porque el texto tmb puede formar parte de una estructura
if (cant<longi)
{
	printf("\nError al escribir el archivo");
}
else
{
	printf("\nSe escribieron %d caracteres", cant);
}
	
fclose(parch);



RECORDAR fflush(stdin); SIEMPRE ANTES DE LA ESCRITURA

Si se trata de un archivo binario el programa será el siguiente:
struct a{
char nombre[10];
int edad;
};
void main (void)
{
FILE *bin;
struct a pers;
bin=fopen("bin.dat","wb");
printf("\nIngrese el nombre: ");
gets(pers.nombre);
printf("Ingrese la edad: ");
scanf("%d",&pers.edad);
fflush(stdin);
fwrite(&pers,sizeof(pers),1,bin);
fclose(bin);
}

el archivo .dat es el que se crea con las funciones para binarios

boton der sobre ese archivo bin.dat y tratar de abrirlo con un editor de textp (va a verse en codigo binario)

el 1er param el puntero no es origen sino destino

con fwrite le digo el origen que esta en la variable, con la funcion de lectura le digo el destino (pero son los mismos parámetros)

retorno la cantidad exacta y sino error porque leyó mal

Ejemplo de lectura de archivo binario:
struct a{
	char nombre[10];
	int edad;
};

void main (void)
{
	FILE *bin;
	struct a pers;
	int cant;
	if ((bin=fopen("bin.dat","rb"))==NULL)
	{
		printf("No se pudo abrir el archivo");
		exit(1);
	}
	while(!feof(bin))
	{
		cant=fread(&pers,sizeof(pers),1,bin);
		if(cant!=1)
	{
	if(feof(bin))
	break;
else
{
error("No leyo el ultimo registro");
break;
}
}
printf("\n%s\t%d",pers.nombre,pers.edad);//imprime lo q leyo de disco
}
fclose(bin);
getch();
}

while(1)//es un bucle infinito

la funcion feof va a devolver True(1) o False(0)

while(!feof(bin)) feof negado sería un Falso negado, resultando en un feof true, es lo mismo que poner
while(feof(bin)==0)

el señalador queda al final de lo que leyó que es el comienzo de lo que va a leer a continuación

cuando termina de leer el archivo vuelve al while y recien cuando pasa por fread no puede leer y se dispara el ifcant!=1 y entra al if de feof(sin el feof va a volver a mostrar el {último registro)


si cambio la estructura con un archivo ya existente, genera un problema, como está medido en bytes, al hacer e cambio, cambia el espacio en bytes, con lo cual se genera un desfasaje, para poder hacer esto

debo leer la estructura original, cada elemento, escribo la nueva estructura en cada elemento, una vez que hago todo ese proceso, borro el archivo viejo

BUSQUEDA Y MODIFICACION

rewind //rebobina el señalador del archivo
fseek //desde donde este el señalador del archivo me permite moverme

SEEK_SET A partir del comienzo del archivo
SEEK_CUR A partir de la posición actual del archivo
SEEK_END A partir de el final del archivo

fseek ( ptr , 0L , SEEK_SET ); //se mueve 0bytes desde el comienzo del archivo

fseek ( ptr , 0L , SEEK_END ); //se mueve 0bytes desde el final del archivo

fseek ( ptr , 20L , SEEK_SET ); //Mueve el indicador de posición 20 bytes a partir del comienzo del archivo.

fseek ( ptr , (long) (-1)*sizeof (struct x) , SEEK_CUR ); //Mueve el indicador de posición una estructura para atras a partir de la posición actual

por ej si leo un registro que está mal, y lo necesito corregir, rebobino, empiezo a buscar leo el primer registro y comparo si coincide con el nro de registro unico e irrepetible que uso para buscar el registro a corregir
lo leo lo encuentro modifico la variable, ahora debo escribir el archivo para corregir el error, si no vuelvo para atras me va a sobreescribir el archivo en el registro siguiente, vuelvo hacia atras al registro a modificar, lo hago multiplicando por -1 para ir hacia atrás en vez de avanzar


ftell va a contar la cantidad de bytes desde el comienzo al final del indicador 
